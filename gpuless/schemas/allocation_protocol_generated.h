// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALLOCATIONPROTOCOL_GPULESS_MANAGER_H_
#define FLATBUFFERS_GENERATED_ALLOCATIONPROTOCOL_GPULESS_MANAGER_H_

#include "flatbuffers/flatbuffers.h"

namespace gpuless {
namespace manager {

struct AllocateRequest;
struct AllocateRequestBuilder;

struct AllocateOffer;
struct AllocateOfferBuilder;

struct AllocateSelect;
struct AllocateSelectBuilder;

struct AllocateConfirm;
struct AllocateConfirmBuilder;

struct DeallocateRequest;
struct DeallocateRequestBuilder;

struct DeallocateConfirm;
struct DeallocateConfirmBuilder;

struct ProtocolMessage;
struct ProtocolMessageBuilder;

enum Status : int8_t {
  Status_OK = 0,
  Status_FAILURE = 1,
  Status_MIN = Status_OK,
  Status_MAX = Status_FAILURE
};

inline const Status (&EnumValuesStatus())[2] {
  static const Status values[] = {
    Status_OK,
    Status_FAILURE
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[3] = {
    "OK",
    "FAILURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (flatbuffers::IsOutRange(e, Status_OK, Status_FAILURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_AllocateRequest = 1,
  Message_AllocateOffer = 2,
  Message_AllocateSelect = 3,
  Message_AllocateConfirm = 4,
  Message_DeallocateRequest = 5,
  Message_DeallocateConfirm = 6,
  Message_MIN = Message_NONE,
  Message_MAX = Message_DeallocateConfirm
};

inline const Message (&EnumValuesMessage())[7] {
  static const Message values[] = {
    Message_NONE,
    Message_AllocateRequest,
    Message_AllocateOffer,
    Message_AllocateSelect,
    Message_AllocateConfirm,
    Message_DeallocateRequest,
    Message_DeallocateConfirm
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[8] = {
    "NONE",
    "AllocateRequest",
    "AllocateOffer",
    "AllocateSelect",
    "AllocateConfirm",
    "DeallocateRequest",
    "DeallocateConfirm",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_DeallocateConfirm)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<gpuless::manager::AllocateRequest> {
  static const Message enum_value = Message_AllocateRequest;
};

template<> struct MessageTraits<gpuless::manager::AllocateOffer> {
  static const Message enum_value = Message_AllocateOffer;
};

template<> struct MessageTraits<gpuless::manager::AllocateSelect> {
  static const Message enum_value = Message_AllocateSelect;
};

template<> struct MessageTraits<gpuless::manager::AllocateConfirm> {
  static const Message enum_value = Message_AllocateConfirm;
};

template<> struct MessageTraits<gpuless::manager::DeallocateRequest> {
  static const Message enum_value = Message_DeallocateRequest;
};

template<> struct MessageTraits<gpuless::manager::DeallocateConfirm> {
  static const Message enum_value = Message_DeallocateConfirm;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AllocateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROFILE = 4,
    VT_SESSION_ID = 6
  };
  int32_t profile() const {
    return GetField<int32_t>(VT_PROFILE, 0);
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PROFILE) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           verifier.EndTable();
  }
};

struct AllocateRequestBuilder {
  typedef AllocateRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_profile(int32_t profile) {
    fbb_.AddElement<int32_t>(AllocateRequest::VT_PROFILE, profile, 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(AllocateRequest::VT_SESSION_ID, session_id, 0);
  }
  explicit AllocateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AllocateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateRequest> CreateAllocateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t profile = 0,
    int32_t session_id = 0) {
  AllocateRequestBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  builder_.add_profile(profile);
  return builder_.Finish();
}

struct AllocateOffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateOfferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_SESSION_ID = 6,
    VT_AVAILABLE_PROFILES = 8
  };
  gpuless::manager::Status status() const {
    return static_cast<gpuless::manager::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  const flatbuffers::Vector<int32_t> *available_profiles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AVAILABLE_PROFILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_AVAILABLE_PROFILES) &&
           verifier.VerifyVector(available_profiles()) &&
           verifier.EndTable();
  }
};

struct AllocateOfferBuilder {
  typedef AllocateOffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::manager::Status status) {
    fbb_.AddElement<int8_t>(AllocateOffer::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(AllocateOffer::VT_SESSION_ID, session_id, 0);
  }
  void add_available_profiles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> available_profiles) {
    fbb_.AddOffset(AllocateOffer::VT_AVAILABLE_PROFILES, available_profiles);
  }
  explicit AllocateOfferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AllocateOffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateOffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateOffer> CreateAllocateOffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::manager::Status status = gpuless::manager::Status_OK,
    int32_t session_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> available_profiles = 0) {
  AllocateOfferBuilder builder_(_fbb);
  builder_.add_available_profiles(available_profiles);
  builder_.add_session_id(session_id);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllocateOffer> CreateAllocateOfferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::manager::Status status = gpuless::manager::Status_OK,
    int32_t session_id = 0,
    const std::vector<int32_t> *available_profiles = nullptr) {
  auto available_profiles__ = available_profiles ? _fbb.CreateVector<int32_t>(*available_profiles) : 0;
  return gpuless::manager::CreateAllocateOffer(
      _fbb,
      status,
      session_id,
      available_profiles__);
}

struct AllocateSelect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateSelectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_SESSION_ID = 6,
    VT_PROFILE = 8
  };
  gpuless::manager::Status status() const {
    return static_cast<gpuless::manager::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  int32_t profile() const {
    return GetField<int32_t>(VT_PROFILE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyField<int32_t>(verifier, VT_PROFILE) &&
           verifier.EndTable();
  }
};

struct AllocateSelectBuilder {
  typedef AllocateSelect Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::manager::Status status) {
    fbb_.AddElement<int8_t>(AllocateSelect::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(AllocateSelect::VT_SESSION_ID, session_id, 0);
  }
  void add_profile(int32_t profile) {
    fbb_.AddElement<int32_t>(AllocateSelect::VT_PROFILE, profile, 0);
  }
  explicit AllocateSelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AllocateSelect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateSelect>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateSelect> CreateAllocateSelect(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::manager::Status status = gpuless::manager::Status_OK,
    int32_t session_id = 0,
    int32_t profile = 0) {
  AllocateSelectBuilder builder_(_fbb);
  builder_.add_profile(profile);
  builder_.add_session_id(session_id);
  builder_.add_status(status);
  return builder_.Finish();
}

struct AllocateConfirm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateConfirmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_SESSION_ID = 6,
    VT_IP = 8,
    VT_PORT = 10
  };
  gpuless::manager::Status status() const {
    return static_cast<gpuless::manager::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  uint32_t ip() const {
    return GetField<uint32_t>(VT_IP, 0);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyField<uint32_t>(verifier, VT_IP) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct AllocateConfirmBuilder {
  typedef AllocateConfirm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::manager::Status status) {
    fbb_.AddElement<int8_t>(AllocateConfirm::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(AllocateConfirm::VT_SESSION_ID, session_id, 0);
  }
  void add_ip(uint32_t ip) {
    fbb_.AddElement<uint32_t>(AllocateConfirm::VT_IP, ip, 0);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(AllocateConfirm::VT_PORT, port, 0);
  }
  explicit AllocateConfirmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AllocateConfirm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateConfirm>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateConfirm> CreateAllocateConfirm(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::manager::Status status = gpuless::manager::Status_OK,
    int32_t session_id = 0,
    uint32_t ip = 0,
    uint16_t port = 0) {
  AllocateConfirmBuilder builder_(_fbb);
  builder_.add_ip(ip);
  builder_.add_session_id(session_id);
  builder_.add_port(port);
  builder_.add_status(status);
  return builder_.Finish();
}

struct DeallocateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeallocateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4
  };
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           verifier.EndTable();
  }
};

struct DeallocateRequestBuilder {
  typedef DeallocateRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(DeallocateRequest::VT_SESSION_ID, session_id, 0);
  }
  explicit DeallocateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeallocateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeallocateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeallocateRequest> CreateDeallocateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0) {
  DeallocateRequestBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

struct DeallocateConfirm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeallocateConfirmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_SESSION_ID = 6
  };
  gpuless::manager::Status status() const {
    return static_cast<gpuless::manager::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           verifier.EndTable();
  }
};

struct DeallocateConfirmBuilder {
  typedef DeallocateConfirm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::manager::Status status) {
    fbb_.AddElement<int8_t>(DeallocateConfirm::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(DeallocateConfirm::VT_SESSION_ID, session_id, 0);
  }
  explicit DeallocateConfirmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeallocateConfirm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeallocateConfirm>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeallocateConfirm> CreateDeallocateConfirm(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::manager::Status status = gpuless::manager::Status_OK,
    int32_t session_id = 0) {
  DeallocateConfirmBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  builder_.add_status(status);
  return builder_.Finish();
}

struct ProtocolMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProtocolMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  gpuless::manager::Message message_type() const {
    return static_cast<gpuless::manager::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const gpuless::manager::AllocateRequest *message_as_AllocateRequest() const {
    return message_type() == gpuless::manager::Message_AllocateRequest ? static_cast<const gpuless::manager::AllocateRequest *>(message()) : nullptr;
  }
  const gpuless::manager::AllocateOffer *message_as_AllocateOffer() const {
    return message_type() == gpuless::manager::Message_AllocateOffer ? static_cast<const gpuless::manager::AllocateOffer *>(message()) : nullptr;
  }
  const gpuless::manager::AllocateSelect *message_as_AllocateSelect() const {
    return message_type() == gpuless::manager::Message_AllocateSelect ? static_cast<const gpuless::manager::AllocateSelect *>(message()) : nullptr;
  }
  const gpuless::manager::AllocateConfirm *message_as_AllocateConfirm() const {
    return message_type() == gpuless::manager::Message_AllocateConfirm ? static_cast<const gpuless::manager::AllocateConfirm *>(message()) : nullptr;
  }
  const gpuless::manager::DeallocateRequest *message_as_DeallocateRequest() const {
    return message_type() == gpuless::manager::Message_DeallocateRequest ? static_cast<const gpuless::manager::DeallocateRequest *>(message()) : nullptr;
  }
  const gpuless::manager::DeallocateConfirm *message_as_DeallocateConfirm() const {
    return message_type() == gpuless::manager::Message_DeallocateConfirm ? static_cast<const gpuless::manager::DeallocateConfirm *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const gpuless::manager::AllocateRequest *ProtocolMessage::message_as<gpuless::manager::AllocateRequest>() const {
  return message_as_AllocateRequest();
}

template<> inline const gpuless::manager::AllocateOffer *ProtocolMessage::message_as<gpuless::manager::AllocateOffer>() const {
  return message_as_AllocateOffer();
}

template<> inline const gpuless::manager::AllocateSelect *ProtocolMessage::message_as<gpuless::manager::AllocateSelect>() const {
  return message_as_AllocateSelect();
}

template<> inline const gpuless::manager::AllocateConfirm *ProtocolMessage::message_as<gpuless::manager::AllocateConfirm>() const {
  return message_as_AllocateConfirm();
}

template<> inline const gpuless::manager::DeallocateRequest *ProtocolMessage::message_as<gpuless::manager::DeallocateRequest>() const {
  return message_as_DeallocateRequest();
}

template<> inline const gpuless::manager::DeallocateConfirm *ProtocolMessage::message_as<gpuless::manager::DeallocateConfirm>() const {
  return message_as_DeallocateConfirm();
}

struct ProtocolMessageBuilder {
  typedef ProtocolMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(gpuless::manager::Message message_type) {
    fbb_.AddElement<uint8_t>(ProtocolMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ProtocolMessage::VT_MESSAGE, message);
  }
  explicit ProtocolMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProtocolMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProtocolMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProtocolMessage> CreateProtocolMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::manager::Message message_type = gpuless::manager::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  ProtocolMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_AllocateRequest: {
      auto ptr = reinterpret_cast<const gpuless::manager::AllocateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateOffer: {
      auto ptr = reinterpret_cast<const gpuless::manager::AllocateOffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateSelect: {
      auto ptr = reinterpret_cast<const gpuless::manager::AllocateSelect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateConfirm: {
      auto ptr = reinterpret_cast<const gpuless::manager::AllocateConfirm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_DeallocateRequest: {
      auto ptr = reinterpret_cast<const gpuless::manager::DeallocateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_DeallocateConfirm: {
      auto ptr = reinterpret_cast<const gpuless::manager::DeallocateConfirm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const gpuless::manager::ProtocolMessage *GetProtocolMessage(const void *buf) {
  return flatbuffers::GetRoot<gpuless::manager::ProtocolMessage>(buf);
}

inline const gpuless::manager::ProtocolMessage *GetSizePrefixedProtocolMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<gpuless::manager::ProtocolMessage>(buf);
}

inline bool VerifyProtocolMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<gpuless::manager::ProtocolMessage>(nullptr);
}

inline bool VerifySizePrefixedProtocolMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<gpuless::manager::ProtocolMessage>(nullptr);
}

inline void FinishProtocolMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gpuless::manager::ProtocolMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProtocolMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gpuless::manager::ProtocolMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace manager
}  // namespace gpuless

#endif  // FLATBUFFERS_GENERATED_ALLOCATIONPROTOCOL_GPULESS_MANAGER_H_
